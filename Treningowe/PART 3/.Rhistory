if(all(ind != sample_indexes)){
sample_indexes[i] <- ind
i <- i + 1
}
}
return(v[sample_indexes])
}
sampling_algorithm(1:8, 0)
sampling_algorithm(1:8, -2)
sampling_algorithm(1:8, 2)
sampling_algorithm <- function(v, n){
if((!(is.numeric(n)) | n <= 0)){
stop('Enter a valid value - n should be a positive number')
}
sample_indexes <- c()
i <- 1
# smaller than minimum for cases when n > length(v)
while(length(sample_indexes) < min(n, length(v))){
ind = ceiling(runif(1, 0, length(v)))
if(all(ind != sample_indexes)){
sample_indexes[i] <- ind
i <- i + 1
}
}
return(v[sample_indexes])
}
sampling_algorithm(1:8, 2)
sampling_algorithm(1:8, -2)
sampling_algorithm(1:8, 0)
sample2b=function(i,a){
if (i<1){
stop("Liczba losowanych elementów musi być większa lub równa 1")
} else if (i%%1!=0){
stop("Liczba losowanych elementów musi być liczbą całkowitą")
} else if (is.vector(a)==F){
stop("Nie podano poprawnego wektora")
} else if (i>length(a)){
stop("Liczba losowanych elementów nie może być większa od liczby elementów wektora")
}
v=numeric(i);
for (k in 1:i){
repeat{
v[k]=a[ceiling(runif(1,0,length(a)))]
if (all(v[k]!=v[1:k-1])){
break
}
}
}
return(v)
}
sample2b(3, 1:8)
sample2b(3, c(1,2,2,2,2))
is.vector(c(1,2,3))
sampling_algorithm <- function(v, n){
if((!(is.numeric(n)) | n <= 0)){
stop('Enter a valid arguments: n should be a positive number')
} else if (!is.vector(v)){
stop('Enter a valid arguments: v should be a vector')
}
sample_indexes <- c()
i <- 1
# smaller than minimum for cases when n > length(v)
while(length(sample_indexes) < min(n, length(v))){
ind = ceiling(runif(1, 0, length(v)))
if(all(ind != sample_indexes)){
sample_indexes[i] <- ind
i <- i + 1
}
}
return(v[sample_indexes])
}
sampling_algorithm(1:8, 3)
sampling_algorithm(2, 3)
sampling_algorithm('a', 3)
is.vector('a')
v =vector();
for (i in 1:2000){
for (j in 1:2000){
v = c(v, i*j)
}
}
v = vector();
for (i in 1:200){
for (j in 1:200){
v = c(v, i*j)
}
}
how_many_end_numbers_1 = function(n){
v = vector();
for (i in 1:n){
for (j in 1:n){
v = c(v, i*j)
}
}
}
how_many_end_numbers_1(200)
v = vector();
how_many_end_numbers_1(200)
how_many_end_numbers_1 = function(n){
v = vector();
for (i in 1:n){
for (j in 1:n){
v = c(v, i*j)
}
}
return(v)
}
how_many_end_numbers_1(200)
v = how_many_end_numbers_1(200)
v = how_many_end_numbers_1(200)
how_many_end_numbers_1 = function(n){
v = vector();
for (i in 1:n){
for (j in 1:n){
v = c(v, i*j)
}
}
}
v = how_many_end_numbers_1(200)
how_many_end_numbers_1 = function(n){
v = vector();
for (i in 1:n){
for (j in 1:n){
v = c(v, i*j)
}
}
return(v)
}
v = how_many_end_numbers_1(200)
5 %% 2
10 %% 3
c(11,12) %% 10
summary(c(11,12) %% 10)
table(c(11,12) %% 10)
as.data.frame(table(c(11,12) %% 10))
how_many_end_numbers_1 = function(n){
v = vector();
for (i in 1:n){
for (j in 1:n){
v = c(v, i*j)
}
}
return(table(vmod = v %% 10))
}
v = how_many_end_numbers_1(200)
v
system.time(
v = how_many_end_numbers_1(200)
)
system.time({
v = how_many_end_numbers_1(200)
}
)
how_many_end_numbers_2 = function(n){
v = vector();
z = 0
for (i in 1:n){
for (j in 1:n){
v[z <- z + 1] = i*j
}
}
return(table(vmod = v %% 10))
}
system.time({
v = how_many_end_numbers_2(200)
}
)
v
# teraz z zadeklarowana wielksocia wektora
how_many_end_numbers_3 = function(n){
v = numeric(n^2);
z = 0
for (i in 1:n){
for (j in 1:n){
v[z <- z + 1] = i*j
}
}
return(table(vmod = v %% 10))
}
system.time({
v = how_many_end_numbers_3(200)
}
)
?outer
outer(1:3, 1:2)
outer(1:3, 1:2, fun = '*')
outer(1:3, 1:2, fun = "*")
outer(1:3, 1:2, FUN = "*")
outer(2:5, 1:2, FUN = "*")
table(outer(2:5, 1:2, FUN = "*"))
library(dplyr)
how_many_end_numbers_4 = function(n){
outer(1:n, 1:n, FUN = "*") %% 10 %>%
table %>%
return
}
system.time({
v = how_many_end_numbers_4(200)
}
)
how_many_end_numbers_5 = function(n){
outer(1:n, 1:n, FUN = "*") %% 10 %>%
tabularate %>%
return
}
system.time({
v = how_many_end_numbers_5(200)
}
)
how_many_end_numbers_5 = function(n){
outer(1:n, 1:n, FUN = "*") %% 10 %>%
tabulate %>%
return
}
system.time({
v = how_many_end_numbers_5(200)
}
)
v
v = how_many_end_numbers_5(2000)
v
# funkcje poliformiczne, czyli takie ktore dzialaja dla roznych klsa
# np funkcja plot - w zaleznosci jakiej klasy jest input to jej dzialanie jest inne
metods(plot)
# funkcje poliformiczne, czyli takie ktore dzialaja dla roznych klsa
# np funkcja plot - w zaleznosci jakiej klasy jest input to jej dzialanie jest inne
methods(plot)
rozmiar <- function(x){
UseMethod("rozmiar")
}
rozmiar.default <- function(x) {
length(x)
}
rozmiar.character <- function(x){
length(x)
}
rozmiar.default <- function(x) {
length(x)
}
rozmiar.character <- function(x){
length(x)
}
rozmiar.matrix <- function(x){
dim(x)[1] * dim(x)[2]
}
rozmiar.array <- function(x){
prod(dim(x))
}
rozmiar(matrix(1,2,3,4))
a = matrix(1,2,3,4)
a
?matrix
matrix(c(1,2,3,4))
a = matrix(c(1,2,3,4), 2, 2)
a
rozmiar(a)
letngth(a)
letngth(a)
length(a)
class(a)
?array
array(c(1:8), dim = c(2,2,2))
b = array(c(1:8), dim = c(2,2,2))
length(b)
b[1,1,1]
b[1,1,2]
b[2,1,1]
b
class(b)
lenght(b)
length(b)
rozmiar(b)
"%op%" <- function(a, b) 2*a+3*b
1 %op% 1
wywolanie <- call('round', 1.59)
wywolanie
eval(wywolanie)
do.call('round', 1.59)
do.call('round', c(1.59, 1))
do.call('round', list(2))
do.call('round', list(2.59))
do.call('round', list(2.59, 1))
#wykorzystac mozna w ponizszy sposob
functions_name <- c('runif', 'norm', 'exp')
functions_name
?sapply(list, function)
?sapply
sapply(functions_name, FUN = do.call)
sapply(functions_name, FUN = do.call, list(3))
#wykorzystac mozna w ponizszy sposob
functions_name <- c('runif', 'rnorm', 'rexp')
sapply(functions_name, FUN = do.call, list(3))
example1 <- function(x = y){
y <- 2
return(x)
}
example1()
y = 1
example1()
example2 <- function(x = y){
x;
y <- 2;
return(x)
}
example2()
example2()
y = 100;
example2()
example1 <- function(a, b){
c = a + b
}
example1(2,4)
example1 <- function(a, b){
c = a + b
return(c)
}
example1(2,4)
example1 <- function(a, b){
c <<- a + b
return(c)
}
example1 <- function(a, b){
c = a + b
return(c)
}
example2 <- function(a, b){
c <<- a + b
return(c)
}
example(2,3)
example2(2,3)
c = 0;
example2 <- function(a, b){
c <<- a + b
return(c)
}
example2(2,3)
c = 0;
# w powyzszej funkcji symbol c jest pamietamy jedynie wewnatrz funkcji, jak widac w global environment nie zapisuje sie zmienna c
example1(2,4)
plot(1:100)
plot(liczby <- 1:100)
plot(liczby = 1:100)
ls()
rm(list = ls())
# tworzac funkcje, tworzy sie nowa przestrzen nazw!
fun_anon <- {
a = 0
f1 <- function(){
a
}
f2 <- function(){
a + 1
}
}
# tworzac funkcje, tworzy sie nowa przestrzen nazw!
fun_anon <- {function(){
a = 0
f1 <- function(){
a
}
f2 <- function(){
a + 1
}
}}()
# tworzac funkcje, tworzy sie nowa przestrzen nazw!
fun_anon <- {function(){
a = 0
f1 <- function(){
a
}
f2 <- function(){
a + 1
}
list(f1 = f1, f2 = f2)
}}()
fun_anon$f1()
fun_anon$f2()
fun_anon$f2()
fun_anon$f1()
fun_anon$f2()
class(fun_anon)
rejestr <- { function(){
licznik <- 0
get <- function() licznik
# tutaj stosujemy <<-, poniewaz chcemy zmienic wartosc obiektu licznik ktory jest w wyzszej przestrzeni nazw
set <- function(x) licznik <<- x
inc <- function() licznik <<- licznik + 1
list(get = get, set = set, inc = inc)
}
}
rejestr <- { function(){
licznik <- 0
get <- function() licznik
# tutaj stosujemy <<-, poniewaz chcemy zmienic wartosc obiektu licznik ktory jest w wyzszej przestrzeni nazw
set <- function(x) licznik <<- x
inc <- function() licznik <<- licznik + 1
list(get = get, set = set, inc = inc)
}}()
rejestr$get()
rejestr$set(5)
rejestr$get()
rejestr$inc()
rejestr$get()
rejestr$inc()
rejestr$get()
rejestr$set(5)
rejestr$get()
imie <- factor('Adrian')
summary(imie)
table(imie)
tabulate(imie)
class(imie)
mode(imie)
typeof(imie)
str(imie)
hist1 <- hist(1:10)
str(imie)
str(hist1)
fix(imie)
a1 = c(1:10)
fix(a1)
attributes(a1)
?tapply
install.packages('SmarterPoland')
library('SmarterPoland')
wypadkiWaska <- getEurostatRCV("tsdtr420")
wypadkiWaska <- getEurostatRCV("tsdtr420")
wypadkiWaska <- getEurostatRCV("sdg_11_40")
head(wypadkiWaska)
library(sqldf)
sqldf(
"
SELECT geo
, AVG(value) AS avg_value
FROM wypadkiWaska
GROUP BY geo
"
)
sqldf(
"
SELECT geo
, AVG(value) AS avg_value
FROM wypadkiWaska
GROUP BY geo
ORDER BY 1
"
)
sqldf(
"
SELECT geo
, AVG(value) AS avg_value
FROM wypadkiWaska
GROUP BY geo
ORDER BY 2 DESC
"
)
library(dplyr)
wypadkiWaska %>%
group_by() %>%
summarise(avg_value = AVG(value))
wypadkiWaska %>%
group_by() %>%
summarise(avg_value = mean(value))
group_by(wypadkiWaska, geo) %>%
summarise(avg_value = mean(value))
group_by(wypadkiWaska, geo) %>%
summarise(avg_value = mean(value)) %>%
arrange(desc(avg_value))
?tapply
tapply(wypadkiWaska$value, wypadkiWaska$geo, FUN = mean)
ex1 <- sqldf(
"
SELECT geo
, AVG(value) AS avg_value
FROM wypadkiWaska
GROUP BY geo
ORDER BY 2 DESC
"
)
class(ex1)
class(ex2)
ex2 <- group_by(wypadkiWaska, geo) %>%
summarise(avg_value = mean(value)) %>%
arrange(desc(avg_value))
class(ex2)
class(ex1)
class(ex2)
mode(ex2)
mode(ex1)
str(ex2)
class(ex3)
ex3 <- tapply(wypadkiWaska$value, wypadkiWaska$geo, FUN = mean)
class(ex3)
mode(ex3)
str(ex3)
head(ex3)
ex3[1]
ex2[1]
ex2[1, ]
?by
ex4 <- by(wypadkiWaska$value, wypadkiWaska$geo, FUN = mean)
ex4
class(ex4)
mode(ex4)
str(ex4)
?aggregate
# mozna tez uzyc funkcji aggregate
aggregate(wypadkiWaska$value, wypadkiWaska$geo, FUN = mean)
# mozna tez uzyc funkcji aggregate
aggregate(wypadkiWaska$value, by = list(wypadkiWaska$geo), FUN = mean)
wypadkiWaska$value > 1000
